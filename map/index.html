<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dead Signal Map</title>
    <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>
    <style>
      html, body, #root {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      /* High specificity for transparent backgrounds */
      html, html > body, html > body > #root {
        background-color: transparent;
        background: none;
      }

      /* Override any dark backgrounds from the React app */
      #root [class*="dark" i],
      #root [class*="bg-" i] {
        background-color: transparent !important;
      }
    </style>
    <script type="module" crossorigin src="/among-guns/map/assets/index-DnFOBFND.js"></script>
    <link rel="stylesheet" crossorigin href="/among-guns/map/assets/index-D2LpBZhN.css">
  </head>

  <body>
    <div id="root"></div>
    <script>
      (function() {
        'use strict';

        const DEBUG = false;
        let latestTaskData = { completed: 0, required: 0, percentage: 0 };

        function log(...args) {
          if (DEBUG) console.log('[Portals Map]', ...args);
        }

        function waitForElement(selector, timeout = 5000) {
          return new Promise((resolve, reject) => {
            const element = document.querySelector(selector);
            if (element) return resolve(element);

            const observer = new MutationObserver(() => {
              const element = document.querySelector(selector);
              if (element) {
                observer.disconnect();
                resolve(element);
              }
            });

            observer.observe(document.getElementById('root'), {
              childList: true,
              subtree: true
            });

            setTimeout(() => {
              observer.disconnect();
              reject(new Error(`Element ${selector} not found within ${timeout}ms`));
            }, timeout);
          });
        }

        function setupCloseButton() {
          // Wait for close button to appear in DOM
          waitForElement('[data-portals-close], [class*="close" i], [aria-label*="close" i]')
            .then(closeButton => {
              log('Close button found, attaching handler');

              closeButton.addEventListener('click', function(e) {
                try {
                  if (typeof PortalsSdk !== 'undefined') {
                    PortalsSdk.closeIframe();
                    log('Iframe closed via Portals SDK');
                  } else {
                    // Fallback: postMessage to parent
                    window.parent.postMessage({ type: 'CLOSE_IFRAME' }, '*');
                    log('Close message sent to parent (SDK unavailable)');
                  }
                } catch (error) {
                  console.error('Failed to close iframe:', error);
                }
              });
            })
            .catch(error => {
              console.warn('Could not find close button:', error.message);
            });
        }

        function applyTaskProgressToDOM(percentage) {
          // Find and update percentage text (look for elements containing %)
          const percentageElements = Array.from(document.querySelectorAll('*')).filter(el => {
            return el.textContent && el.textContent.includes('%') &&
                   el.children.length === 0 && // leaf node
                   /^\d+%$/.test(el.textContent.trim());
          });

          log('Looking for percentage elements, found:', percentageElements.length);
          if (percentageElements.length === 0) {
            // Try to find ANY elements with % in them
            const anyPercent = Array.from(document.querySelectorAll('*')).filter(el =>
              el.textContent && el.textContent.includes('%')
            );
            log('Found', anyPercent.length, 'elements containing %');
            anyPercent.slice(0, 3).forEach(el => {
              log('  Example:', el, 'text:', el.textContent, 'children:', el.children.length);
            });
          }

          percentageElements.forEach(el => {
            log('Checking percentage element:', el.textContent.trim(), 'vs target:', percentage + '%');
            if (el.textContent.trim() !== percentage + '%') {
              el.textContent = percentage + '%';
              log('Updated percentage element to:', percentage + '%');

              // Find the progress bar container (the inline-grid sibling)
              const container = el.parentElement;
              if (container) {
                // Look for the inline-grid sibling
                const siblings = Array.from(container.children);
                const progressBarContainer = siblings.find(sibling =>
                  sibling !== el && sibling.className.includes('inline-grid')
                );

                if (progressBarContainer) {
                  log('Found progress bar container:', progressBarContainer);

                  // Look inside for SVG or other progress elements
                  const svgs = progressBarContainer.querySelectorAll('svg');
                  const rects = progressBarContainer.querySelectorAll('rect');
                  const divs = progressBarContainer.querySelectorAll('div');

                  log('Found in progress container:', svgs.length, 'SVGs,', rects.length, 'rects,', divs.length, 'divs');

                  // Try to update SVG rect widths
                  rects.forEach(rect => {
                    const currentWidth = parseFloat(rect.getAttribute('width')) || 0;
                    const parent = rect.closest('svg');
                    if (parent) {
                      // Get the total width from viewBox or clientWidth
                      const viewBox = parent.viewBox.baseVal;
                      const totalWidth = viewBox ? viewBox.width : parent.clientWidth;
                      const targetWidth = (percentage / 100) * totalWidth;

                      if (Math.abs(currentWidth - targetWidth) > 0.1) {
                        rect.setAttribute('width', targetWidth);
                        log('Updated SVG rect width from', currentWidth, 'to', targetWidth);
                      }
                    }
                  });

                  // Try to update div widths (only update the green progress bar, not the background)
                  divs.forEach(div => {
                    // Only update if it looks like a progress bar (has green color or no fixed width class)
                    const isBackground = div.className.includes('bg-[#141d23]') || div.className.includes('w-[');
                    if (!isBackground) {
                      const targetWidth = percentage + '%';
                      div.style.width = targetWidth;
                      log('Updated progress bar width to:', targetWidth, div);
                    }
                  });
                } else {
                  log('Could not find inline-grid progress bar container');
                }
              }
            }
          });

          // Try to find and update progress bar with multiple strategies
          const progressSelectors = [
            '[class*="progress" i]',
            '[role="progressbar"]',
            '[class*="bar" i]',
            'svg [class*="progress" i]',
            'rect[class*="progress" i]',
            '[class*="fill" i]'
          ];

          progressSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            log('Found', elements.length, 'elements for selector:', selector);

            elements.forEach(el => {
              const targetWidth = percentage + '%';
              log('Checking element:', el, 'current width:', el.style.width);

              // Try setting width
              if (el.style.width !== targetWidth) {
                el.style.width = targetWidth;
                log('Set width to:', targetWidth, 'on element:', el);
              }

              // Try setting transform (some progress bars use scale)
              const scaleX = percentage / 100;
              if (el.style.transform && !el.style.transform.includes('scale')) {
                el.style.transform = `scaleX(${scaleX})`;
                log('Set scaleX to:', scaleX, 'on element:', el);
              }

              // Try setting attributes
              if (el.setAttribute) {
                el.setAttribute('aria-valuenow', percentage);
                el.setAttribute('aria-valuemin', 0);
                el.setAttribute('aria-valuemax', 100);
              }

              // If it's an SVG rect, try setting width attribute
              if (el.tagName === 'rect') {
                const parent = el.closest('svg');
                if (parent) {
                  const viewBoxWidth = parent.viewBox?.baseVal?.width || parent.clientWidth || 100;
                  const rectWidth = (percentage / 100) * viewBoxWidth;
                  el.setAttribute('width', rectWidth);
                  log('Set SVG rect width to:', rectWidth, 'on element:', el);
                }
              }
            });
          });
        }

        function updateTaskProgress(completed, required) {
          const percentage = required > 0 ? Math.round((completed / required) * 100) : 0;

          // Store latest data
          latestTaskData = { completed, required, percentage };

          // Apply to DOM immediately
          applyTaskProgressToDOM(percentage);

          // Dispatch custom event for React app (in case it's listening)
          const event = new CustomEvent('portalsTaskUpdate', {
            detail: { completed, required, percentage }
          });
          window.dispatchEvent(event);
        }

        function setupProgressUpdateObserver() {
          // Watch for DOM changes and re-apply progress if React re-renders
          const observer = new MutationObserver(function() {
            if (latestTaskData.percentage > 0) {
              applyTaskProgressToDOM(latestTaskData.percentage);
            }
          });

          // Start observing once root is available
          waitForElement('#root').then(root => {
            observer.observe(root, {
              childList: true,
              subtree: true,
              characterData: true
            });
            log('Progress update observer started');
          });
        }

        function setupTaskProgressListener() {
          // Listen for messages from Portals (same system as status-bar.html)
          if (typeof PortalsSdk !== 'undefined' && PortalsSdk.setMessageListener) {
            PortalsSdk.setMessageListener(function(message) {
              log('PORTALS MSG:', message);

              // Parse the message to extract taskscompleted and tasksrequired
              const completedMatch = message.match(/taskscompleted\s*:\s*(\d+)/);
              const requiredMatch = message.match(/tasksrequired\s*:\s*(\d+)/);

              if (completedMatch && requiredMatch) {
                const completed = parseInt(completedMatch[1]);
                const required = parseInt(requiredMatch[1]);
                log('Updating task progress:', completed, '/', required);

                updateTaskProgress(completed, required);
              }
            });
            log('Task progress listener initialized');
          } else {
            console.warn('PortalsSdk.setMessageListener not available');
          }
        }

        // Initialize when DOM is ready
        function initialize() {
          setupCloseButton();
          setupTaskProgressListener();
          setupProgressUpdateObserver();
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initialize);
        } else {
          initialize();
        }
      })();
    </script>
  </body>
</html>
