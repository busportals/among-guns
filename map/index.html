<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dead Signal Map</title>
    <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>
    <style>
      html, body, #root {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      /* High specificity for transparent backgrounds */
      html, html > body, html > body > #root {
        background-color: transparent;
        background: none;
      }

      /* Override any dark backgrounds from the React app */
      #root [class*="dark" i],
      #root [class*="bg-" i] {
        background-color: transparent !important;
      }
    </style>
    <script type="module" crossorigin src="/among-guns/map/assets/index-DnFOBFND.js"></script>
    <link rel="stylesheet" crossorigin href="/among-guns/map/assets/index-D2LpBZhN.css">
  </head>

  <body>
    <div id="root"></div>
    <script>
      (function() {
        'use strict';

        const DEBUG = false;
        let latestTaskData = { completed: 0, required: 0, percentage: 0 };

        function log(...args) {
          if (DEBUG) console.log('[Portals Map]', ...args);
        }

        function waitForElement(selector, timeout = 5000) {
          return new Promise((resolve, reject) => {
            const element = document.querySelector(selector);
            if (element) return resolve(element);

            const observer = new MutationObserver(() => {
              const element = document.querySelector(selector);
              if (element) {
                observer.disconnect();
                resolve(element);
              }
            });

            observer.observe(document.getElementById('root'), {
              childList: true,
              subtree: true
            });

            setTimeout(() => {
              observer.disconnect();
              reject(new Error(`Element ${selector} not found within ${timeout}ms`));
            }, timeout);
          });
        }

        function setupCloseButton() {
          // Wait for close button to appear in DOM
          waitForElement('[data-portals-close], [class*="close" i], [aria-label*="close" i]')
            .then(closeButton => {
              log('Close button found, attaching handler');

              closeButton.addEventListener('click', function(e) {
                try {
                  if (typeof PortalsSdk !== 'undefined') {
                    PortalsSdk.closeIframe();
                    log('Iframe closed via Portals SDK');
                  } else {
                    // Fallback: postMessage to parent
                    window.parent.postMessage({ type: 'CLOSE_IFRAME' }, '*');
                    log('Close message sent to parent (SDK unavailable)');
                  }
                } catch (error) {
                  console.error('Failed to close iframe:', error);
                }
              });
            })
            .catch(error => {
              console.warn('Could not find close button:', error.message);
            });
        }

        function applyTaskProgressToDOM(percentage) {
          // Find and update percentage text (look for elements containing %)
          const percentageElements = Array.from(document.querySelectorAll('*')).filter(el => {
            return el.textContent && el.textContent.includes('%') &&
                   el.children.length === 0 && // leaf node
                   /^\d+%$/.test(el.textContent.trim());
          });

          percentageElements.forEach(el => {
            if (el.textContent.trim() !== percentage + '%') {
              el.textContent = percentage + '%';
              log('Updated percentage element to:', percentage + '%');
            }
          });

          // Try to find and update progress bar
          const progressBars = document.querySelectorAll('[class*="progress" i], [role="progressbar"]');
          progressBars.forEach(bar => {
            const targetWidth = percentage + '%';
            if (bar.style.width !== targetWidth) {
              bar.style.width = targetWidth;
              log('Updated progress bar width to:', targetWidth);
            }
            if (bar.setAttribute) {
              bar.setAttribute('aria-valuenow', percentage);
              bar.setAttribute('aria-valuemin', 0);
              bar.setAttribute('aria-valuemax', 100);
            }
          });
        }

        function updateTaskProgress(completed, required) {
          const percentage = required > 0 ? Math.round((completed / required) * 100) : 0;

          // Store latest data
          latestTaskData = { completed, required, percentage };

          // Apply to DOM immediately
          applyTaskProgressToDOM(percentage);

          // Dispatch custom event for React app (in case it's listening)
          const event = new CustomEvent('portalsTaskUpdate', {
            detail: { completed, required, percentage }
          });
          window.dispatchEvent(event);
        }

        function setupProgressUpdateObserver() {
          // Watch for DOM changes and re-apply progress if React re-renders
          const observer = new MutationObserver(function() {
            if (latestTaskData.percentage > 0) {
              applyTaskProgressToDOM(latestTaskData.percentage);
            }
          });

          // Start observing once root is available
          waitForElement('#root').then(root => {
            observer.observe(root, {
              childList: true,
              subtree: true,
              characterData: true
            });
            log('Progress update observer started');
          });
        }

        function setupTaskProgressListener() {
          // Listen for messages from Portals (same system as status-bar.html)
          if (typeof PortalsSdk !== 'undefined' && PortalsSdk.setMessageListener) {
            PortalsSdk.setMessageListener(function(message) {
              log('PORTALS MSG:', message);

              // Parse the message to extract taskscompleted and tasksrequired
              const completedMatch = message.match(/taskscompleted\s*:\s*(\d+)/);
              const requiredMatch = message.match(/tasksrequired\s*:\s*(\d+)/);

              if (completedMatch && requiredMatch) {
                const completed = parseInt(completedMatch[1]);
                const required = parseInt(requiredMatch[1]);
                log('Updating task progress:', completed, '/', required);

                updateTaskProgress(completed, required);
              }
            });
            log('Task progress listener initialized');
          } else {
            console.warn('PortalsSdk.setMessageListener not available');
          }
        }

        // Initialize when DOM is ready
        function initialize() {
          setupCloseButton();
          setupTaskProgressListener();
          setupProgressUpdateObserver();
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initialize);
        } else {
          initialize();
        }
      })();
    </script>
  </body>
</html>
